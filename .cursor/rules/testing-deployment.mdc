---
description: 
globs: *.test.ts
alwaysApply: false
---
# Testing & Deployment Strategies

## Testing Philosophy

- **Test Critical Paths First**: Focus on authentication, payment flows, and data integrity
- **Integration Over Unit Tests**: For single developer, integration tests provide more value
- **Use Real Services in Tests**: Test against actual Cloudflare services using Miniflare
- **Snapshot Testing for UI**: Quick regression detection for Astro components

## Bun Test Patterns

```typescript
// packages/platform/src/api/patient-requests.test.ts
import { describe, expect, test, beforeAll, afterAll } from "bun:test";
import { unstable_dev } from "wrangler";
import type { UnstableDevWorker } from "wrangler";

describe("Patient Request API", () => {
  let worker: UnstableDevWorker;

  beforeAll(async () => {
    // Start local worker with test environment
    worker = await unstable_dev("src/index.ts", {
      experimental: { disableExperimentalWarning: true },
      vars: {
        ENVIRONMENT: "test",
        TEST_TENANT_ID: "test-tenant-123",
      },
    });
  });

  afterAll(async () => {
    await worker.stop();
  });

  test("should handle patient request with DSGVO compliance", async () => {
    const response = await worker.fetch("/api/patient-requests", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Tenant-ID": "test-tenant-123",
      },
      body: JSON.stringify({
        email: "patient@example.com",
        name: "Test Patient",
        message: "I need therapy",
        consent: true,
      }),
    });

    expect(response.status).toBe(201);

    const data = await response.json();
    expect(data).toMatchObject({
      id: expect.any(String),
      status: "pending",
      consentRecorded: true,
    });
  });
});
```

## Test Organization

```
packages/[package-name]/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ feature/
â”‚   â”‚   â”œâ”€â”€ feature.ts
â”‚   â”‚   â””â”€â”€ feature.test.ts    # Co-located unit tests
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration/           # Integration tests
â”‚   â”œâ”€â”€ e2e/                  # End-to-end tests
â”‚   â””â”€â”€ fixtures/             # Test data and mocks
â””â”€â”€ test-utils/              # Shared test utilities
```

## Healthcare-Specific Test Cases

```typescript
// Always test these scenarios for healthcare compliance
describe("Healthcare Compliance", () => {
  test("should encrypt patient data before storage", async () => {
    const patientData = { name: "Test", diagnosis: "Anxiety" };
    const stored = await storePatientData(patientData);

    // Verify data is encrypted
    expect(stored.data).not.toContain("Test");
    expect(stored.data).not.toContain("Anxiety");
    expect(stored.encrypted).toBe(true);
  });

  test("should require consent before processing", async () => {
    const response = await processWithoutConsent();
    expect(response.status).toBe(403);
    expect(response.error).toContain("consent required");
  });

  test("should log all data access", async () => {
    await accessPatientData("patient-123");
    const logs = await getAuditLogs("patient-123");

    expect(logs).toContainEqual(
      expect.objectContaining({
        action: "READ",
        resourceId: "patient-123",
        timestamp: expect.any(Date),
      })
    );
  });
});
```

## Performance Testing

```typescript
// Monitor Worker performance constraints
test("should complete request within CPU limits", async () => {
  const start = performance.now();

  await processComplexRequest();

  const duration = performance.now() - start;
  expect(duration).toBeLessThan(10); // 10ms CPU limit for free tier
});

test("should handle concurrent requests", async () => {
  const requests = Array(50)
    .fill(null)
    .map(() => worker.fetch("/api/health"));

  const responses = await Promise.all(requests);
  const successCount = responses.filter((r) => r.status === 200).length;

  expect(successCount).toBe(50);
});
```

## Deployment Pipeline

```yaml
# .github/workflows/deploy.yml
name: Deploy VRLY Platform

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Type check
        run: bun run type-check

      - name: Run tests
        run: bun test

      - name: Check DSGVO compliance
        run: bun run scripts/compliance-check.ts

  deploy-preview:
    if: github.event_name == 'pull_request'
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1

      - name: Deploy preview
        run: |
          bun run deploy --env preview
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Comment preview URL
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              body: `ðŸš€ Preview deployed: https://preview-${context.issue.number}.vrly.de`
            })

  deploy-production:
    if: github.ref == 'refs/heads/main'
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1

      - name: Deploy to production
        run: |
          bun run deploy --env production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Run post-deployment tests
        run: |
          bun run scripts/post-deploy-test.ts --env production

      - name: Notify deployment
        run: |
          curl -X POST ${{ secrets.WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{"text": "VRLY Platform deployed to production"}'
```

## Local Development Testing

```bash
# Run all tests
bun test

# Run specific package tests
bun test packages/platform

# Run with coverage
bun test --coverage

# Run in watch mode
bun test --watch

# Run only integration tests
bun test tests/integration
```

## Deployment Strategies

```typescript
// scripts/deployment/rolling-deploy.ts
async function rollingDeploy(environment: "staging" | "production") {
  console.log(`ðŸš€ Starting rolling deployment to ${environment}`);

  // 1. Deploy to canary (5% traffic)
  await deployToCanary(environment);
  await sleep(5 * 60 * 1000); // Wait 5 minutes

  // 2. Check canary metrics
  const canaryHealthy = await checkCanaryHealth();
  if (!canaryHealthy) {
    await rollbackCanary();
    throw new Error("Canary deployment failed health checks");
  }

  // 3. Gradually increase traffic
  for (const percentage of [25, 50, 75, 100]) {
    await updateTrafficSplit(percentage);
    await sleep(2 * 60 * 1000); // Wait 2 minutes

    const healthy = await checkHealth();
    if (!healthy) {
      await rollback();
      throw new Error(`Deployment failed at ${percentage}% traffic`);
    }
  }

  console.log("âœ… Deployment completed successfully");
}
```

## Database Migration Testing

```typescript
// Always test migrations before applying
describe("Database Migrations", () => {
  test("migration should be reversible", async () => {
    const db = await getTestDatabase();

    // Apply migration
    await applyMigration(db, "add-appointment-table");
    expect(await tableExists(db, "appointments")).toBe(true);

    // Rollback migration
    await rollbackMigration(db, "add-appointment-table");
    expect(await tableExists(db, "appointments")).toBe(false);
  });

  test("migration should preserve existing data", async () => {
    const db = await getTestDatabase();
    const beforeData = await db.prepare("SELECT * FROM patients").all();

    await applyMigration(db, "add-patient-preferences");

    const afterData = await db.prepare("SELECT * FROM patients").all();
    expect(afterData.length).toBe(beforeData.length);
  });
});
```

## Monitoring & Rollback

```typescript
// Automated rollback on errors
async function deployWithMonitoring(package: string) {
  const deployment = await deploy(package);

  // Monitor for 10 minutes
  const monitoringPeriod = 10 * 60 * 1000;
  const startTime = Date.now();

  while (Date.now() - startTime < monitoringPeriod) {
    const metrics = await getDeploymentMetrics(deployment.id);

    if (metrics.errorRate > 0.05) {
      // 5% error threshold
      console.error("High error rate detected, rolling back...");
      await rollback(deployment);
      throw new Error("Deployment rolled back due to high error rate");
    }

    await sleep(30 * 1000); // Check every 30 seconds
  }

  console.log("âœ… Deployment stable");
}
```

## Quick Test Commands

```json
// package.json scripts
{
  "scripts": {
    "test": "bun test",
    "test:watch": "bun test --watch",
    "test:coverage": "bun test --coverage",
    "test:integration": "bun test tests/integration",
    "test:e2e": "bun test tests/e2e",
    "test:ci": "bun test --bail --no-coverage",
    "deploy:preview": "wrangler deploy --env preview",
    "deploy:staging": "wrangler deploy --env staging",
    "deploy:production": "bun run scripts/deploy.ts production"
  }
}
```
