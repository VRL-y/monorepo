---
description: 
globs: 
alwaysApply: false
---
# Healthcare Compliance & Security

## Critical Compliance Requirements

- **DSGVO/GDPR**: Full compliance with European data protection laws
- **§203 StGB**: German criminal code for medical confidentiality
- **Data Minimization**: Only collect and store necessary data
- **Purpose Limitation**: Use data only for stated purposes
- **Encryption**: End-to-end encryption for patient data

## Data Classification

```typescript
// Classify data sensitivity levels
enum DataSensitivity {
  Public = "PUBLIC", // Marketing content
  Internal = "INTERNAL", // Business operations
  Confidential = "CONFIDENTIAL", // Client business data
  Restricted = "RESTRICTED", // Patient health data
}

// Tag all data models with sensitivity
interface IPatientRecord {
  _sensitivity: DataSensitivity.Restricted;
  id: PatientId;
  therapistId: TherapistId;
  // All patient data is restricted by default
}
```

## Encryption Patterns

```typescript
// Always encrypt patient data at rest
import { encrypt, decrypt } from "@vrly/shared/crypto";

// Encrypt before storing in database
async function storePatientData(data: IPatientData, env: Env) {
  const encrypted = await encrypt(JSON.stringify(data), env.ENCRYPTION_KEY);

  await env.VRLY_DB.prepare(
    "INSERT INTO patients (id, tenant_id, data) VALUES (?, ?, ?)"
  )
    .bind(data.id, data.tenantId, encrypted)
    .run();
}

// Decrypt after retrieval
async function getPatientData(id: string, tenantId: string, env: Env) {
  const result = await env.VRLY_DB.prepare(
    "SELECT data FROM patients WHERE id = ? AND tenant_id = ?"
  )
    .bind(id, tenantId)
    .first();

  if (!result) return null;

  const decrypted = await decrypt(result.data as string, env.ENCRYPTION_KEY);
  return JSON.parse(decrypted) as IPatientData;
}
```

## Audit Logging

```typescript
// Log all access to patient data
interface IAuditLog {
  timestamp: Date;
  userId: string;
  action: "CREATE" | "READ" | "UPDATE" | "DELETE";
  resourceType: string;
  resourceId: string;
  tenantId: string;
  ip?: string;
  userAgent?: string;
}

async function logDataAccess(log: IAuditLog, env: Env) {
  // Store in separate audit table with retention policy
  await env.VRLY_DB.prepare(
    `
      INSERT INTO audit_logs 
      (timestamp, user_id, action, resource_type, resource_id, tenant_id, ip, user_agent)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `
  )
    .bind(
      log.timestamp.toISOString(),
      log.userId,
      log.action,
      log.resourceType,
      log.resourceId,
      log.tenantId,
      log.ip,
      log.userAgent
    )
    .run();
}
```

## Data Retention & Deletion

```typescript
// Implement data retention policies
const RETENTION_PERIODS = {
  patientRecords: 10 * 365, // 10 years in days
  auditLogs: 3 * 365, // 3 years
  sessions: 30, // 30 days
  tempData: 7, // 7 days
} as const;

// Automatic data deletion
async function deleteExpiredData(env: Env) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - RETENTION_PERIODS.patientRecords);

  // Soft delete with audit trail
  await env.VRLY_DB.prepare(
    `
      UPDATE patients 
      SET deleted_at = CURRENT_TIMESTAMP,
          data = NULL
      WHERE created_at < ? AND deleted_at IS NULL
    `
  )
    .bind(cutoffDate.toISOString())
    .run();
}
```

## Consent Management

```typescript
// Track and validate consent
interface IConsent {
  patientId: PatientId;
  type: "DATA_PROCESSING" | "MARKETING" | "ANALYTICS";
  granted: boolean;
  grantedAt?: Date;
  revokedAt?: Date;
  ipAddress: string;
  version: string; // Version of consent text
}

// Check consent before processing
async function checkConsent(
  patientId: PatientId,
  consentType: IConsent["type"],
  env: Env
): Promise<boolean> {
  const consent = await env.VRLY_DB.prepare(
    `
      SELECT granted, revoked_at 
      FROM consents 
      WHERE patient_id = ? AND type = ?
      ORDER BY granted_at DESC
      LIMIT 1
    `
  )
    .bind(patientId, consentType)
    .first();

  return consent?.granted === 1 && !consent?.revoked_at;
}
```

## Access Control

```typescript
// Role-based access control
enum Role {
  Patient = "PATIENT",
  Therapist = "THERAPIST",
  Admin = "ADMIN",
  SuperAdmin = "SUPER_ADMIN",
}

// Permissions matrix
const PERMISSIONS = {
  [Role.Patient]: ["read:own-data", "update:own-data"],
  [Role.Therapist]: [
    "read:patient-data",
    "update:patient-data",
    "create:patient-data",
  ],
  [Role.Admin]: ["read:all-data", "update:settings", "read:audit-logs"],
  [Role.SuperAdmin]: ["*"], // All permissions
} as const;

// Enforce access control
function canAccess(userRole: Role, action: string, resource: string): boolean {
  const permissions = PERMISSIONS[userRole];
  return (
    permissions.includes("*") || permissions.includes(`${action}:${resource}`)
  );
}
```

## Secure Communication

```typescript
// Email templates with privacy notices
const EMAIL_FOOTER = `
Diese E-Mail kann vertrauliche Informationen enthalten. 
Wenn Sie nicht der beabsichtigte Empfänger sind, 
informieren Sie bitte den Absender und löschen Sie diese E-Mail.

This email may contain confidential information.
If you are not the intended recipient, 
please notify the sender and delete this email.
`;

// Never send patient data via unencrypted email
function sanitizeForEmail(text: string): string {
  // Remove any patient identifiers
  return text
    .replace(/\b\d{4,}\b/g, "[ID]") // Remove IDs
    .replace(/\b[A-Z][a-z]+\s[A-Z][a-z]+\b/g, "[NAME]"); // Remove names
}
```

## Security Headers

```typescript
// Apply security headers to all responses
function addSecurityHeaders(response: Response): Response {
  const headers = new Headers(response.headers);

  headers.set("X-Content-Type-Options", "nosniff");
  headers.set("X-Frame-Options", "DENY");
  headers.set("X-XSS-Protection", "1; mode=block");
  headers.set("Referrer-Policy", "strict-origin-when-cross-origin");
  headers.set("Permissions-Policy", "geolocation=(), microphone=(), camera=()");

  // HSTS for HTTPS enforcement
  headers.set(
    "Strict-Transport-Security",
    "max-age=31536000; includeSubDomains"
  );

  // CSP for XSS protection
  headers.set(
    "Content-Security-Policy",
    "default-src 'self'; " +
      "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
      "style-src 'self' 'unsafe-inline'; " +
      "img-src 'self' data: https:; " +
      "connect-src 'self' https://api.vrly.de;"
  );

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers,
  });
}
```

## Data Export (DSGVO Article 20)

```typescript
// Implement data portability
async function exportPatientData(patientId: PatientId, env: Env) {
  // Collect all data related to the patient
  const [records, consents, auditLogs] = await Promise.all([
    getPatientRecords(patientId, env),
    getPatientConsents(patientId, env),
    getPatientAuditLogs(patientId, env),
  ]);

  // Format as JSON (machine-readable)
  const exportData = {
    exportDate: new Date().toISOString(),
    patientId,
    records,
    consents,
    auditLogs: auditLogs.map((log) => ({
      ...log,
      // Anonymize other user references
      userId: log.userId === patientId ? log.userId : "[REDACTED]",
    })),
  };

  // Create encrypted ZIP file
  return createEncryptedArchive(exportData);
}
```
