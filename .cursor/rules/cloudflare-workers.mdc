---
description: 
globs: wrangler.jsonc,**/wrangler.jsonc,scripts/**
alwaysApply: false
---
# Cloudflare Workers Development Patterns

## Workers Architecture

- Use Workers for Platforms for multi-tenant isolation
- Each tenant gets their own Worker sandbox
- Implement proper routing with the platform Worker as API gateway
- Use Service Bindings for inter-Worker communication

## Environment Bindings

```typescript
// Always type your environment bindings
interface Env {
  // KV Namespaces
  VRLY_CONFIG: KVNamespace;
  VRLY_SESSIONS: KVNamespace;

  // D1 Databases
  VRLY_DB: D1Database;

  // R2 Buckets
  VRLY_STORAGE: R2Bucket;
  VRLY_DOCUMENTS: R2Bucket;

  // Vectorize
  VRLY_VECTORS: VectorizeIndex;

  // AI
  VRLY_AI: Ai;

  // Queues
  VRLY_QUEUE: Queue;

  // Analytics
  VRLY_ANALYTICS: AnalyticsEngineDataset;

  // Environment variables
  ENVIRONMENT: "development" | "staging" | "production";
}
```

## Request Handling Pattern

```typescript
export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    // Always use structured error handling
    try {
      // Extract tenant from subdomain or header
      const tenant = extractTenant(request);

      // Implement request routing
      const url = new URL(request.url);

      // Use Durable Objects for stateful operations
      // Use KV for configuration and sessions
      // Use D1 for structured data
      // Use R2 for file storage

      return new Response("Success", { status: 200 });
    } catch (error) {
      return handleError(error, env);
    }
  },

  // Queue consumers for async processing
  async queue(batch: MessageBatch<any>, env: Env): Promise<void> {
    for (const message of batch.messages) {
      // Process with automatic retries
    }
  },
};
```

## Performance Optimizations

- Use `cache` API for edge caching
- Implement stale-while-revalidate patterns
- Use `waitUntil()` for non-blocking operations
- Minimize subrequests (max 50 per request)
- Keep CPU time under 10ms (50ms for paid plans)

## Security Patterns

- Validate all inputs at the edge
- Implement proper CORS handling
- Use Cloudflare Access for admin endpoints
- Store secrets in environment variables, not code
- Implement rate limiting with Cloudflare or custom logic

## Multi-Tenant Data Isolation

```typescript
// Always scope data access by tenant
async function getTenantData(env: Env, tenantId: string, key: string) {
  return await env.VRLY_DB.prepare(
    "SELECT * FROM data WHERE tenant_id = ? AND key = ?"
  )
    .bind(tenantId, key)
    .first();
}
```

## Error Handling

```typescript
function handleError(error: unknown, env: Env): Response {
  console.error("Worker error:", error);

  // Log to Analytics Engine for monitoring
  env.VRLY_ANALYTICS.writeDataPoint({
    blobs: ["error"],
    doubles: [Date.now()],
    indexes: [error instanceof Error ? error.name : "UnknownError"],
  });

  // Return user-friendly error
  return new Response(JSON.stringify({ error: "Internal Server Error" }), {
    status: 500,
    headers: { "Content-Type": "application/json" },
  });
}
```

[wrangler.jsonc](mdc:wrangler.jsonc)
